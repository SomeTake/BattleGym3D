//=============================================================================
//
// AI処理 [AI.cpp]
// Author : HAL東京 GP11B341-17 80277 染谷武志
//
//=============================================================================
#include "AI.h"
#include "camera.h"

//*****************************************************************************
// マクロ定義
//*****************************************************************************

//*****************************************************************************
// グローバル変数
//*****************************************************************************

//*****************************************************************************
// プロトタイプ宣言
//*****************************************************************************

//=====================================================================================================
// 右肩上がりのグラフを作成するメンバーシップ関数
// 引数:value = 値, x0 = 下限値, x1 = 上限値
//=====================================================================================================
float FuzzyGrade(float value, float x0, float x1)
{
	float x = value;

	if (x <= x0)
	{
		return 0;
	}
	else if (x >= x1)
	{
		return 1;
	}
	else
	{
		// 分母を計算
		float denom = x1 - x0;
		return (x / denom) - (x0 / denom);
	}
}

//=====================================================================================================
// 右肩下がりのグラフを作成するメンバーシップ関数
// 引数:value = 値, x0 = 下限値, x1 = 上限値
//=====================================================================================================
float FuzzyReverseGrade(float value, float x0, float x1)
{
	float x = value;

	if (x <= 0)
	{
		return 1;
	}
	else if (x >= x1)
	{
		return 0;
	}
	else
	{
		float denom = x1 - x0;
		return (x1 / denom) - (x / denom);
	}
}

//=====================================================================================================
// 台形のグラフを作成するメンバーシップ関数
// 引数:value = 値, x0 = 右肩上がりの下限値, x1 = 右肩上がりの上限値, x2 = 右肩下がりの下限値, x3 = 右肩下がりの上限値
//=====================================================================================================
float FuzzyTrapezoid(float value, float x0, float x1, float x2, float x3)
{
	float x = value;

	if (x <= x0)
	{
		return 0;
	}
	else if ((x >= x1) && (x <= x2))
	{
		return 1;
	}
	else if ((x > x0) && (x < x1))
	{
		float denom = x1 - x0;
		return (x / denom) - (x0 / denom);
	}
	else
	{
		float denom = x3 - x2;
		return (x3 / denom) - (x / denom);
	}
}

//=====================================================================================================
// 論理和
//=====================================================================================================
float FuzzyOr(float a, float b)
{
	if (a > b)
	{
		return a;
	}
	else
	{
		return b;
	}
}

//=====================================================================================================
// 論理積
//=====================================================================================================
float FuzzyAnd(float a, float b)
{
	if (a > b)
	{
		return b;
	}
	else
	{
		return a;
	}
}

//=====================================================================================================
// 論理否定
//=====================================================================================================
float FuzzyNot(float a, float b)
{
	return 1.0f - a;
}

//=====================================================================================================
// ファジーAI
//=====================================================================================================
void FuzzyAI(CHARA *Chara)
{
	float distNear = 0.0f;			// 近い
	float distNormal = 0.0f;		// 普通
	float distFar = 0.0f;			// 遠い

	float dist = GetPEdistance();	// プレイヤー間の距離取得

	// ファジー入力
	distNear = FuzzyReverseGrade(dist, NEAR_MIN, NEAR_MAX);
	distNormal = FuzzyTrapezoid(dist, NEAR_MIN, NEAR_MAX, FAR_MIN, FAR_MAX);
	distFar = FuzzyGrade(dist, FAR_MIN, FAR_MAX);

	float stateApproach = 0.0f;		// 近づく
	float stateAttack = 0.0f;		// 攻撃する

	// ファジー推論
	stateAttack = distNear;
	stateApproach = FuzzyOr(distNormal, distFar);

	// 非ファジー化
	float fuzzyvalue = 0.0f;
	if (stateAttack >= stateApproach)
	{
		fuzzyvalue = stateAttack;
	}
	else
	{
		fuzzyvalue = stateApproach;
	}
}
